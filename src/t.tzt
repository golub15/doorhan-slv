  HandleLed(&led_1, LED_A_GPIO_PIN);
    HandleLed(&led_2, LED_B_GPIO_PIN);

    UpdateSwitch(&btn);
    UpdateSwitch(&sw_close);
    UpdateSwitch(&sw_open);
    UpdateSwitch(&start);

    // uint8_t start_sig = !GPIO_ReadInputPin(START_GPIO_PORT, START_GPIO_PIN); // НP

    uint8_t stop_sig = GPIO_ReadInputPin(STOP_GPIO_PORT, STOP_GPIO_PIN);  // НЗ
    uint8_t ph_cl = GPIO_ReadInputPin(PH_CL_GPIO_PORT, PH_CL_GPIO_PIN); // НЗ

    // Обработка безопасности

    // 1. Кнопка СТОП

    // + DIP4
    stop_sig |= !GPIO_ReadInputPin(DP4_GPIO_PORT, DP4_GPIO_PIN); // НО

    if (stop_sig != last_stop)
    {
        last_stop = stop_sig;

        if (stop_sig)
        {
            StartBlink(&led_2, 10, 10);
            // init = 0;
            gate_state.position = GATE_UNKNOWN;

            StopMotor(0);
        }
        else
        {
            StartBlink(&led_2, 1, 0);
            GPIO_WriteHigh(LED_A_GPIO_PORT, LED_A_GPIO_PIN);
            prev_motor_error = 0;
        }
    }

    // if (stop_sig)
    // {
    //     if (open_sw_state || close_sw_state || ph_cl)
    //         GPIO_WriteLow(LED_A_GPIO_PORT, LED_A_GPIO_PIN);
    //     else
    //         GPIO_WriteHigh(LED_A_GPIO_PORT, LED_A_GPIO_PIN);

    //     return;
    // }

    // 2. Фотоэлементы
    if (motor_state.power && photo.sw_state && motor_state.direction == DIR_CLOSE)
    {
        StartMotor(DIR_OPEN, motor_state.time_on);
        // gate_state.current_dir = GATE_OPEN;
    }

    // Обработчик ошибок/аварий
    if (motor_state.errors != prev_motor_error)
    {
        // Запоминаем если появились ошибки
        // Ждем и пробуем открыться или закрыться (по тек. положени)
        StartBlink(&led_2, 1, motor_state.errors);

        if (!motor_state.errors)
        {
            // 1. низкое напряжение = как только норма = сброс
            if (prev_motor_error & MOTOR_LV_ERR_MASK && gate_state.position != GATE_CLOSE)
            {
                // init = 0;
                gate_state.position = GATE_UNKNOWN;
            }
        }

        // 2. Перегрузка по силе (току),
        // при закрытии, ждем, затем, открываемся
        // при открытии, ждем время и заново

        if (motor_state.errors & MOTOR_OC_ERR_MASK)
        {
            gate_state.position = GATE_UNKNOWN;
            // motor_state.errors = 0x00;
        }

        // 3. Превышение времени открытия = особый случай
        // Считаем что в нужном положенни

        if (motor_state.errors & MOTOR_OT_ERR_MASK)
        {
            // Нет концевого после открытия, считаем что открылись
            gate_state.position = motor_state.last_dir;

            if (gate_state.position == GATE_OPEN)
            {
                last_opening_time = millis();
            }
            // gate_state.current_dir = GATE_NO_MOVE;

            motor_state.errors = 0x00;
        }

        prev_motor_error = motor_state.errors;
    }

    // Закрытие после препятствий фото-элемента

    // Автозакрытие
    if (!ph_cl &&
        auto_close &&
        gate_state.position == GATE_OPEN &&
        motor_state.direction == DIR_NO_MOVE &&
        millis() - last_opening_time > device_config.auto_close_time)
    {
        StartMotor(DIR_CLOSE, MAX_CLOSEING_TIME);
    }

    // Начало работы
    // пробуем открыться, если не получилось, по обычной логике
    if (!init &&
        !(motor_state.errors & MOTOR_LV_ERR_MASK) &&
        motor_state.direction == DIR_NO_MOVE &&
        gate_state.position == GATE_UNKNOWN)
    {
        init = 0x01;
        time_init = millis();
    }

    if (init && millis() - time_init >
                    (motor_state.errors & MOTOR_OC_ERR_MASK ? OVER_FORCE_DELAY : INIT_DELAY))
    {
        if (motor_state.errors & MOTOR_OC_ERR_MASK)
        {

            if (try_OС_clear <= 10)
            {
                StartMotor(DIR_OPEN, MAX_CLOSEING_TIME - motor_state.time_on);
                try_OС_clear++;
                motor_state.errors &= ~MOTOR_OC_ERR_MASK;
            }
        }
        else
            StartMotor(DIR_OPEN, MAX_CLOSEING_TIME);

        init = 0x00;
    }